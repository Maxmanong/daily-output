// Webpack 的运行流程是一个串行的过程， 从启动到结束会依次执行以下流程：

// 初始化参数： 从配置文件和 Shell 语句中读取与合并参数， 得出最终的参数
// 开始编译： 用上一步得到的参数初始化 Compiler 对象， 加载所有配置的插件， 执行对象的 run 方法开始执行编译
// 确定入口： 根据配置中的 entry 找出所有的入口文件
// 编译模块： 从入口文件出发， 调用所有配置的 Loader 对模块进行翻译， 再找出该模块依赖的模块， 再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
// 完成模块编译： 在经过第4步使用 Loader 翻译完所有模块后， 得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
// 输出资源： 根据入口和模块之间的依赖关系， 组装成一个个包含多个模块的 Chunk， 再把每个 Chunk 转换成一个单独的文件加入到输出列表， 这步是可以修改输出内容的最后机会
// 输出完成： 在确定好输出内容后， 根据配置确定输出的路径和文件名， 把文件内容写入到文件系统

// 在以上过程中， Webpack 会在特定的时间点广播出特定的事件， 插件在监听到感兴趣的事件后会执行特定的逻辑， 并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。
// 简单说

// 初始化： 启动构建， 读取与合并配置参数， 加载 Plugin， 实例化 Compiler
// 编译： 从 Entry 出发， 针对每个 Module 串行调用对应的 Loader 去翻译文件的内容， 再找到该 Module 依赖的 Module， 递归地进行编译处理
// 输出： 将编译后的 Module 组合成 Chunk， 将 Chunk 转换成文件， 输出到文件系统中


//  Webpack 的热更新原理吧
//      (敲黑板， 这道题必考)
//  Webpack 的热更新又称热替换（ Hot Module Replacement）， 缩写为 HMR。 
//  这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。
//  HMR的核心就是客户端从服务端拉去更新后的文件， 准确的说是 chunk diff(chunk 需要更新的部分)，
//  实际上 WDS 与浏览器之间维护了一个 Websocket， 当本地资源发生变化时， WDS 会向浏览器推送更新，
//  并带上构建时的 hash， 让客户端与上一次资源进行对比。 
//  客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、 hash)，
//  这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。
//  后续的部分(拿到增量更新之后如何处理？ 哪些状态该保留？ 哪些又需要更新？) 由 HotModulePlugin 来完成，
//  提供了相关 API 以供开发者针对自身场景进行处理， 像react - hot - loader 和 vue - loader 都是借助这些 API 实现 HMR。
