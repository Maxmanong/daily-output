## React Hooks 约定：

#####  一、强制约定：只能在「函数组件/自定义Hooks」中调用Hooks，不能在普通js函数/类组件中调用；有且只有这两种环境中调用；

#####  	原因：React会在「函数式组件/自定义Hooks」的执行上下文中维护一个维护一个「Hooks调用链表」，用于追踪每一个Hook对应的状态。普通JS函数和类组件没有这个专属上下文，React无法建议Hooks与组件状态的关联，会直接抛出错误。

##### 二、只能在函数顶层调用Hooks，不能在「条件/循环/嵌套函数」中调用Hooks；

​	原因：React 不通过 “变量名” 或 “参数” 来区分 Hooks，而是通过「每次渲染时的调用顺序」来关联状态。例如：

​		第一次渲染：第 1 个 `useState` 对应状态 A，第 2 个 `useState` 对应状态 B，第 1 个 `useEffect` 对应副作用 C；

​		第二次渲染：React 会按照「相同的顺序」，将第 1 个 `useState` 对应到状态 A，第 2 个 `useState` 对应到状态 B；

​		若 Hooks 被包裹在条件语句中，条件变化会导致调用顺序改变，React 会混淆状态与 Hooks 的对应关系，导致状态错乱或报错

简单的说：Hooks 的调用顺序必须是「固定不变」的，不能随组件状态变化而改变。

#####  三、规范约定 ：自定义 Hooks 必须以「use」开头命名，自定义 Hooks 的函数名必须遵循「`useXXX`」的命名规范（首字母小写 `use`，后面跟大写字母开头的驼峰命名）；

​	原因：

​		**可读性强**：开发者能快速识别这是自定义 Hooks，而非普通工具函数，便于代码维护和协作；

​		**Lint 校验支持**：React 官方的 `eslint-plugin-react-hooks` 插件会根据「`use` 开头」的命名，自动检测自定义 Hooks 内部及使用处的 Hooks 合规性，提前规避隐藏 bug；

​		**生态一致性**：这是 React 社区的通用规范，所有第三方自定义 Hooks（如 `useRequest`、`useLocalStorage`）均遵循此约定，保证生态一致性。

##### 四、 规范约定：Hooks 依赖数组必须「准确配置」，不遗漏、不冗余；

​	原因：依赖数组是 React 判定 Hooks 「是否需要重新执行」的唯一依据：

​	遗漏依赖：Hooks 无法捕获最新的变量值，导致闭包陷阱（获取到旧状态），业务逻辑异常；

​	冗余依赖：Hooks 会随无关变量变化而重复执行，造成性能浪费；

​	不稳定依赖：导致 Hooks 每次渲染都重复执行，失去缓存意义。

##### 五、 补充约定：useState 的更新函数，若依赖旧状态，优先使用「函数式更新」，当通过 `setState` 更新状态时，若新状态依赖于旧状态（如 `count = count + 1`），优先使用「函数式更新」（传入一个接收旧状态的函数），而非直接使用旧状态变量；

​	原因：避免闭包陷阱导致的状态更新异常，尤其是在异步操作、定时器中，直接使用旧状态变量可能获取到渲染时的旧值，而函数式更新会始终获取到最新的旧状态。

##### React Hooks 的约定核心是「保证 Hooks 调用顺序固定」和「状态追踪准确」，核心约定可归纳为：

1. 「强制」：仅在函数组件 / 自定义 Hooks 中调用 Hooks；
2. 「强制」：仅在函数顶层作用域调用 Hooks，不嵌套在条件 / 循环 / 嵌套函数中；
3. 「规范」：自定义 Hooks 必须以 `use` 开头命名；
4. 「规范」：依赖数组准确配置（不遗漏、不冗余、不稳定）；
5. 「规范」：`useState` 依赖旧状态时，优先使用函数式更新。

这些约定不是限制，而是 React 为了简化状态管理、保证性能稳定而设计的规则，遵守这些约定能有效避免绝大多数 Hooks 相关的 bug。