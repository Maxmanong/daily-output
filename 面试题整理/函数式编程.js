/**
 * @description 函数式编程
 * 1、 函数出现的目的
 * 函数是迄今为止发明出来的用于节约空间和提高性能的最重要的手段。没有之一。
 * 
 * 
 * 2、函数的执行机制
 * 执行一个函数， 会发生什么？
 * （1）创建函数
 * 第一步： 开辟一个新的堆内存
 * 第二步：创建一个函数 say， 把这个函数体中的代码放在这个堆内存中。
 *       这些语句以字符串的形式放在堆内存中比较好， 因为没有规律。
 *       如果是对象， 由于有规律， 可以按照键值对的形式存储在堆内存中。 而没规律的通常都是变成字符串的形式。
 * 第三步： 在当前上下文中声明 say 函数(变量)， 函数声明和定义会提升到最前面。
 *        当前上下文， 我们可以理解为上下文堆栈(栈)， say 是放在堆栈(栈) 中的， 
 *        同时它的右边还有一个堆内存地址， 用来指向堆中的函数体的。
 * 第四步：把开辟的堆内存地址赋值给函数名 say
 * 
 * （2）赋值操作
 * 赋值(引用类型) 的操作就是将堆区域的某一个地址， 通过总线管道流入(复制) 到对应栈区域的某一个地址中，
 *  从而使栈区域的某一个地址内的存储空间中有了引用堆区域数据的地址。 业界叫句柄， 也就是指针。
 *  只不过在高级语言中， 把指针隐藏了， 直接用变量代替指针。
 * 在赋值这个操作上， 本质上是数据或者数据的句柄在一张地址表中的流动。
 * 如果是值类型， 那就是直接把数据， 流(移动) 到指定内存地址的存储空间中。
 * 
 * （3）执行函数
 * 函数体的代码是以字符串形式的保存在堆内存中的。 如果我们要执行堆内存中的代码， 
 * 首先要将字符串变成真正的 JS 代码， 就像数据传输中的序列化和反序列化。
 * 
 * （4）将字符串变成真正的 JS 代码
 *  为什么函数执行要在栈中执行呢？
 *  每一个函数调用， 都会在函数上下文堆栈中创建帧。 栈是一个基本的数据结构。
 *  函数上下文堆栈是一个数据结构， 这个结构体负责管理函数执行已经关闭变量作用域。 
 *  函数上下文堆栈在程序运行时产生，并且一开始加入到栈里面的是全局上下文帧， 位于栈底。
 * 
 * （5）开始执行函数
 *  首先要明白一点： 执行函数(函数调用) 是在栈上完成的。
 *  这也就是为什么 JS 函数可以递归。 因为栈先进后出的数据结构， 赋予了其递归能力。
 *  第一步： 形成一个供代码执行的环境， 也是一个栈内存。
 *  第二步： 将存储的字符串复制一份到新开辟的栈内存中， 使其变为真正的 JS 代码。
 *  第三步： 先对形参进行赋值， 再进行变量提升， 比如将 var function 变量提升。
 *  第四步： 在这个新开辟的作用域中自上而下执行。
 *  this 只有在运行时才会存在。
 *  作用域链本质就是链表， 执行哪个函数， 链表就初始化为哪个函数的作用域， 
 *  然后将该函数的[scope] 放在表头， 形成闭环链表。 作用域链是通过链表查找的，
 *  如果走了一圈还没找到， 那就返回 undefined。
 * 
 * 
 *  */

function kun() {
    var result = []
    for (var i = 0; i < 10; i++) {
        result[i] = function () {
            return i
        }
    }
    return result
}

let r = kun()
// 输出十个10
r.forEach(fn => {
    console.log('fn: ', fn())
})
// result 数组中的每一个函数其作用域都已经确定了， 
// 而 JS 是静态作用域语言，其在程序声明阶段，所有的作用域都将确定。
// result 数组中每一个函数其作用域链如下：AO(result[i]) --> AO(kun) --> VO(G)
// 因此 result 中的每一个函数执行时， 其 i 的值都是沿着这条作用域链去查找的，
// 而且由于 kun 函数只执行了一次， 导致了 i 值是最后的结果， 也就是 10。 
// 所以输出结果就是 10 个 10。



function kun1() {
    var result = []
    for (var i = 0; i < 10; i++) {
        result[i] = (function (n) {
            return function () {
                return n
            }
        })(i)
    }
    return result
}

let r1 = kun1()

// 输出0到9
r1.forEach(fn => {
    console.log('fn1: ', fn())
})
// 首先， 在声明函数 kun 的时候， 就已经执行了 10 次匿名函数。 函数在执行时将生成执行环境， 也就意味着， 
// 在 ECS 栈中， 有 10 个 EC(kun) 执行环境， 分别对应result 数组中的 10 个函数。
// 执行 result 数组中的 10 个函数时， 运行10 个不同的链表， 同时每个链表的 AO(kun) 节点是不一样的。
//  每个 AO(kun) 节点中的 i 值也是不一样的。

// 所以输出的结果最后显示为 0 到 9。


/**
 * @description 函数式编程的 5 问
 * 
 * 一、 为什么函数式编程要避免使用this
 * 1、JS 的 this 有多种含义， 使用场景复杂。 this 不取决于函数体内的代码。
 * 2、所有的数据都应以参数的形式提供给函数， 而 this 不遵守这种规则。
 * 
 * 二、 为什么JS函数内部可以使用for循环？
 * 循环语句需要使用递归实现， 但是 JS 的递归性能并不好， 比如没有尾递归优化， 那怎么办呢？
 * 为了能支持函数式编程， 又要避免 JS 的递归性能问题。 最后允许了函数内部可以使用 for 循环
 * 
 * 
 * 三、 JS函数是一等公民是啥意识？ 这样做的目的是啥？
 * 1、能够表达为匿名的直接量
 * 2、能被变量存储
 * 3、能被其它数据结构存储
 * 4、有独立而确定的名称(如语法关键字)
 * 5、可比较的
 * 6、可作为参数传递
 * 7、可作为函数结果值返回
 * 8、在运行期可创建
 * 9、能够以序列化的形式表达
 * 10、可(以自然语言的形式) 读的
 * 11、可(以自然语言能在分布的或运行中的进程中传递与存储形式) 读的
 * 
 * 
 * 四、 在JS中， 如何做到函数式编程 ?
 * 核心思想： 通过表达式消灭掉语句。
 * 1、 通过表达式消灭分支语句 举例： 单个 if 语句， 可以通过布尔表达式消灭掉
 * 2、 通过函数递归消灭循环语句
 * 3、 用函数去代替值(函数只有返回的值在影响系统的运算， 一个函数调用过程其实只相当于表达式运算中的一个求值)
 * 
 * 
 * 五、 用 JS 进行函数式编程的缺点是什么？
 * 1、 缺少不可变数据结构(JS 除了原始类型， 其他都是可变的)
 * 2、 没有提供一个原生的利于组合函数而产生新函数的方式， 需要第三方支持
 * 3、 不支持惰性序列
 * 4、 缺少尾递归优化
 * 5、 JS 的函数不是真正纯种函数式语言中的函数形式(比如 JS 函数中可以写循环语句)
 * 6、 表达式支持赋值
 * 
 * 
 * 最近的 react Hooks 到 Vue 3.0 的 Function API。函数式编程的影响力在慢慢变大。
 */